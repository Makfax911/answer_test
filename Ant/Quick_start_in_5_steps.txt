Apache Ant должен быть знаком каждому Java-программисту: это популярный инструмент сборки ПО (build tool), полностью написанный на Java. Ant использует сценарий, который является обычным XML-файлом. Несмотря на его Java-направленность, веб-разработчики тоже используют этот инструмент.

Мы пройдём пять простых шагов, чтобы начать использовать Ant:
1. Скачаем, установим и проверим.
2. Напишем простой HelloWorld сценарий.
3. Разберёмся с принципами работы и XML форматом сценария сборки.
4. Узнаем минимально необходимый список заданий.
5. Напишем сценарий для полного цикла сборки и тестирования учебного проекта.

Нам потребуется Java SE Development Kit (JDK, скачиваем по адресу http://www.oracle.com/technetwork/java/javase/downloads), ваш любимый текстовый редактор (в Linux – vi/vim/gedit, для Windows рекомендую Notepad++) и базовые навыки работы в командной строке. Сценарии сборки и примеры на Java протестированы в Linux (Simply Linux 7.95.0, CentOS Linux 6.8) и в Windows (XP/7). Использование Ant одинаково и в Linux и в Windows.

1. Скачиваем, устанавливаем, проверяем

Linux: устанавливаем из репозитария командой вроде sudo apt-get install ant (замените apt-get на yum если необходимо). Важно: нам нужна версия не ниже 1.8.*. В репозитарии CentOS 6.8 версия 1.7.1, поэтому лучше использовать скрипт (https://github.com/biblelamp/LinuxExercises/blob/master/CentOS/installantoncentos.sh), описанный в предыдущей статье (https://habrahabr.ru/post/323246/).

Windows: посещаем веб-сайт https://ant.apache.org/, заходим в раздел Download/Binary Distributions и скачиваем архив apache-ant-1.10.1-bin.zip (возможно сейчас есть уже более свежая версия). Содержимое архива копируем в любой каталог, например в "C:\Program Files\Apache Ant". Затем добавляем путь к каталогу bin (C:\Program Files\Apache Ant\bin) в системную переменную Path.

Проверяем работоспособность, вызвав ant в командной строке:

$ ant -version
Apache Ant(TM) version 1.10.1 compiled on February 2 2017

Если аналогичное сообщение получено – всё в порядке.

2. Пишем HelloWorld сценарий

<?xml version="1.0"?>
<project name="HelloWorld" default="hello">
    <target name="hello">
        <echo>Hello, World!</echo>
    </target>
</project>

Создаём в домашнем каталоге подкаталог hello (в Linux это делает команда mkdir, в Windows – md) и сохраняем туда файл с именем build.xml, содержащий предложенный выше сценарий. Переходим в этот каталог и вызываем ant:

$ mkdir hello
$ cd hello
$ ant
Buildfile: /home/lamp/hello/build.xml

hello:
     [echo] Hello, World!
BUILD SUCCESSFULL

Total time: 0 seconds

Что произошло? Ant нашел файл сценария с именем по умолчанию (build.xml) и выполнил target c именем hello, также указанный по умолчанию в теге project с помощью атрибута default (обратите внимание что в теге project мы ещё указали имя проекта, используя атрибут name). Мы получим такой же результат, если при вызове ant укажем в качестве параметра hello:

$ ant hello

3. Основные принципы работы

Сценарий сборки – обычный XML-файл. Текст открывается (и закрывается) тегом project, в котором можно указать имя проекта и цель по умолчанию. Далее он содержит определение целей (target), зависимостей (depends) и свойств (property). Простейший сценарий должен иметь хотя бы одну цель. В теге target мы описываем вызов одного или нескольких заданий (tasks). Для target можно задать имя с помощью атрибута name (name="name_of_target"). Заданное имя становится командой для нашего сценария и вызвать соответствующий target можно так:

$ ant name_of_target

В target есть возможность указать зависимость с помощью атрибута depends. Зависимости связывают target'ы между собой. Например, есть target c именем “compile”, а есть – с именем “run”, зависимый от “compile”. И если мы захотим выполнить “run”, сначала выполнится “compile”.

4. Минимально необходимый список заданий (tasks)

Стандартная версия Ant содержит более 150 заданий (https://ant.apache.org/manual/tasklist.html). Нам пока потребуются только семь:

echo – вывод сообщений в консоль
mkdir – создание директорий
delete – удаление файлов и директорий
javac – компиляция Java–кода
java – запуск class и jar файлов
jar – создание jar файла
junit – запуск тестов

5. Сценарий для сборки и тестирования Java проекта

Ant предоставляет полную свободу в формировании структуры каталогов. Создаём в нашем каталоге hello подкаталог src для исходных текстов на Java:

$ mkdir src

И сохраняем туда файл HelloWorld.java следующего содержания:

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

А затем немного усложняем текст нашего сценария (build.xml):

<?xml version="1.0"?>
<project name="HelloWorld" default="run">
    <target name="compile" depends="mkdir">
        <mkdir dir="build/classes"/>
        <javac destdir="build/classes" includeantruntime="false">
            <src path="src"/>
        </javac>
    </target>
    <target name="run" depends="compile">
        <java classname="HelloWorld" classpath="build/classes"/>
    </target>
    <target name="clean">
        <delete dir="build"/>
    </target>
</project>

Теперь сценарий содержит три target (команды): compile (компиляция файла(ов) .java), run (запуск файла .class), clean (удаление папок с результатами компиляции). При этом compile содержит два tasks – mkdir и javac. Обратите внимание на зависимость: target run предварительно вызовет compile. Кроме того run – это target по умолчанию для проекта.

Запускаем сценарий без параметров и видим результат работы Java программы: Hello, World!

Прямое указание имен каталогов не говорит о хорошем стиле. Особенно если имена в сценарии повторяются. Модифицируем build.xml, используя property (обратите внимание, как нам пригодилось имя проекта, заданное в project) и добавив пару комментариев:

 <?xml version="1.0"?>
 <project name="HelloWorld" default="run">
     <!-- define names of directories -->
     <property name="src" location="src"/>
     <property name="build" location="build"/>
     <property name="classes" location="${build}/classes"/>
     <!-- define all targets -->
     <target name="compile">
         <mkdir dir="${classes}"/>
         <javac srcdir="${src}" destdir="${classes}" includeAntRuntime="false"/>
     </target>
     <target name="run" depends="compile">
         <java classname="${ant.project.name}" classpath="${classes}"/>
     </target>
     <target name="clean">
         <delete dir="${build}"/>
     </target>
 </project>

Теперь добавим в сценарий target  package для формирования jar файла:

<target name="package" depends="compile">
    <jar destfile="${build}/${ant.project.name}.jar" basedir="${classes}">
        <manifest>
            <attribute name="Main–Class" value="${ant.project.name}"/>
        </manifest>
    </jar>
</target>

и убедимся что всё работает:

$ ant package
$ java -jar build/HelloWorld.jar
Hello, World!

Перейдём к тестированию. Изменим код проекта (чтобы было что тестировать):

public class HelloWorld {
    public static void main(String[] args) {
        HelloWorld hello = new HelloWorld();
        System.out.println(hello.sayHello());
    }
    String sayHello() {
        return "Hello, World!";
    }
}

и добавим в каталог src файл/класс TestHello.java с простым тестом:

import static org.junit.Assert.assertEquals;
import org.junit.Test;
public class TestHello {
    @Test
    public void testHello() {
        HelloWorld hello = new HelloWorld();
        assertEquals("Hello, World!", hello.sayHello());
    }
}

Используя информацию со страницы https://github.com/junit-team/junit4/wiki/getting-started загружаем два файла, junit-4.12.jar и hamcrest-core-1.3.jar и копируем их в каталог нашего JDK/jre/lib/ext (такую команду копирования используем в CentOS 6.8):

$ sudo cp ~/Downloads/*.jar /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.121-0.b13.el6_8.i386/jre/lib/ext/

Теперь можно проверить как работает тест в командной строке:

$ java -cp build/classes org.junit.runner.JUnitCore TestHello
JUnit version 4.12
.
Time: 0,281
OK (1 test)

Добавляем в наш сценарий ещё один target – test:

<target name="test" depends="compile">
    <junit>
        <classpath>
            <pathelement location="${classes}"/>
        </classpath>
        <test name="TestHello"/>
    </junit>
</target>

и дополняем строку в target package (jar):

<jar destfile="${build}/${ant.project.name}.jar" basedir="${classes}" excludes="Test*.class">

Теперь к списку команд нашего сценария (compile, run, package, clean) добавилась test.
В заключение меняем код нашего проекта так, чтобы приветствие выводилось в отдельном графическом окне. Затем формируем jar файл и запускаем его двойным кликом мыши (у вас должно быть настроено выполнение jar файлов по двойному клику).

Третья версия Java кода:

import javax.swing.*;
import java.awt.*;
public class HelloWorld extends JFrame {
    public static void main(String[] args) {
        new HelloWorld();
    }
    HelloWorld() {
        setTitle(sayHello());
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setBounds(200, 200, 300, 200);
        JLabel label = new JLabel(sayHello(), SwingConstants.CENTER);
        label.setFont(new Font("", Font.BOLD, 24));
        add(label);
        setVisible(true);
    }
    String sayHello() {
        return "Hello, World!";
    }
}

Слегка дополняем сценарий (в target run), дописав fork="true" (запуск выполнения класса в другой виртуальной машине). В противном случае run не сработает (проверено экспериментально):

<java classname="${ant.project.name}" classpath="${classes}" fork="true"/>

Выполняем команду формирования jar файла ($ ant package), открываем в проводнике файлов каталог ~/hello/build, находим там HelloWorld.jar, дважды кликаем по нему мышкой и получаем удовольствие от созерцания графического окошка с приветствием.
